"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseCommand = exports.joinCommand = exports.getEscapedCommand = void 0;
require("core-js/modules/es.string.replace.js");
require("core-js/modules/esnext.async-iterator.map.js");
require("core-js/modules/esnext.iterator.map.js");
require("core-js/modules/web.dom-collections.iterator.js");
const normalizeArgs = function (file) {
  let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (!Array.isArray(args)) {
    return [file];
  }
  return [file, ...args];
};
const NO_ESCAPE_REGEXP = /^[\w.-]+$/;
const DOUBLE_QUOTES_REGEXP = /"/g;
const escapeArg = arg => {
  if (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {
    return arg;
  }
  return "\"".concat(arg.replace(DOUBLE_QUOTES_REGEXP, '\\"'), "\"");
};
const joinCommand = (file, args) => normalizeArgs(file, args).join(' ');
exports.joinCommand = joinCommand;
const getEscapedCommand = (file, args) => normalizeArgs(file, args).map(arg => escapeArg(arg)).join(' ');
exports.getEscapedCommand = getEscapedCommand;
const SPACES_REGEXP = / +/g;

// Handle `execaCommand()`
const parseCommand = command => {
  const tokens = [];
  for (const token of command.trim().split(SPACES_REGEXP)) {
    // Allow spaces to be escaped by a backslash if not meant as a delimiter
    const previousToken = tokens[tokens.length - 1];
    if (previousToken && previousToken.endsWith('\\')) {
      // Merge previous token with current one
      tokens[tokens.length - 1] = "".concat(previousToken.slice(0, -1), " ").concat(token);
    } else {
      tokens.push(token);
    }
  }
  return tokens;
};
exports.parseCommand = parseCommand;