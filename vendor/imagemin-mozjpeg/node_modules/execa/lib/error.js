"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeError = void 0;
require("core-js/modules/esnext.async-iterator.filter.js");
require("core-js/modules/esnext.iterator.constructor.js");
require("core-js/modules/esnext.iterator.filter.js");
var _main = require("../../human-signals/build/src/main.js");
const getErrorPrefix = _ref => {
  let {
    timedOut,
    timeout,
    errorCode,
    signal,
    signalDescription,
    exitCode,
    isCanceled
  } = _ref;
  if (timedOut) {
    return "timed out after ".concat(timeout, " milliseconds");
  }
  if (isCanceled) {
    return 'was canceled';
  }
  if (errorCode !== undefined) {
    return "failed with ".concat(errorCode);
  }
  if (signal !== undefined) {
    return "was killed with ".concat(signal, " (").concat(signalDescription, ")");
  }
  if (exitCode !== undefined) {
    return "failed with exit code ".concat(exitCode);
  }
  return 'failed';
};
const makeError = _ref2 => {
  let {
    stdout,
    stderr,
    all,
    error,
    signal,
    exitCode,
    command,
    escapedCommand,
    timedOut,
    isCanceled,
    killed,
    parsed: {
      options: {
        timeout
      }
    }
  } = _ref2;
  // `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.
  // We normalize them to `undefined`
  exitCode = exitCode === null ? undefined : exitCode;
  signal = signal === null ? undefined : signal;
  const signalDescription = signal === undefined ? undefined : _main.signalsByName[signal].description;
  const errorCode = error && error.code;
  const prefix = getErrorPrefix({
    timedOut,
    timeout,
    errorCode,
    signal,
    signalDescription,
    exitCode,
    isCanceled
  });
  const execaMessage = "Command ".concat(prefix, ": ").concat(command);
  const isError = Object.prototype.toString.call(error) === '[object Error]';
  const shortMessage = isError ? "".concat(execaMessage, "\n").concat(error.message) : execaMessage;
  const message = [shortMessage, stderr, stdout].filter(Boolean).join('\n');
  if (isError) {
    error.originalMessage = error.message;
    error.message = message;
  } else {
    error = new Error(message);
  }
  error.shortMessage = shortMessage;
  error.command = command;
  error.escapedCommand = escapedCommand;
  error.exitCode = exitCode;
  error.signal = signal;
  error.signalDescription = signalDescription;
  error.stdout = stdout;
  error.stderr = stderr;
  if (all !== undefined) {
    error.all = all;
  }
  if ('bufferedData' in error) {
    delete error.bufferedData;
  }
  error.failed = true;
  error.timedOut = Boolean(timedOut);
  error.isCanceled = isCanceled;
  error.killed = killed && !timedOut;
  return error;
};
exports.makeError = makeError;