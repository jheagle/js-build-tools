"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateTimeout = exports.spawnedKill = exports.spawnedCancel = exports.setupTimeout = exports.setExitHandler = void 0;
require("core-js/modules/es.promise.finally.js");
require("core-js/modules/web.dom-collections.iterator.js");
var _nodeOs = _interopRequireDefault(require("node:os"));
var _signalExit = require("signal-exit");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;

// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior
const spawnedKill = function (kill) {
  let signal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'SIGTERM';
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const killResult = kill(signal);
  setKillTimeout(kill, signal, options, killResult);
  return killResult;
};
exports.spawnedKill = spawnedKill;
const setKillTimeout = (kill, signal, options, killResult) => {
  if (!shouldForceKill(signal, options, killResult)) {
    return;
  }
  const timeout = getForceKillAfterTimeout(options);
  const t = setTimeout(() => {
    kill('SIGKILL');
  }, timeout);

  // Guarded because there's no `.unref()` when `execa` is used in the renderer
  // process in Electron. This cannot be tested since we don't run tests in
  // Electron.
  // istanbul ignore else
  if (t.unref) {
    t.unref();
  }
};
const shouldForceKill = (signal, _ref, killResult) => {
  let {
    forceKillAfterTimeout
  } = _ref;
  return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
};
const isSigterm = signal => signal === _nodeOs.default.constants.signals.SIGTERM || typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM';
const getForceKillAfterTimeout = _ref2 => {
  let {
    forceKillAfterTimeout = true
  } = _ref2;
  if (forceKillAfterTimeout === true) {
    return DEFAULT_FORCE_KILL_TIMEOUT;
  }
  if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
    throw new TypeError("Expected the `forceKillAfterTimeout` option to be a non-negative integer, got `".concat(forceKillAfterTimeout, "` (").concat(typeof forceKillAfterTimeout, ")"));
  }
  return forceKillAfterTimeout;
};

// `childProcess.cancel()`
const spawnedCancel = (spawned, context) => {
  const killResult = spawned.kill();
  if (killResult) {
    context.isCanceled = true;
  }
};
exports.spawnedCancel = spawnedCancel;
const timeoutKill = (spawned, signal, reject) => {
  spawned.kill(signal);
  reject(Object.assign(new Error('Timed out'), {
    timedOut: true,
    signal
  }));
};

// `timeout` option handling
const setupTimeout = (spawned, _ref3, spawnedPromise) => {
  let {
    timeout,
    killSignal = 'SIGTERM'
  } = _ref3;
  if (timeout === 0 || timeout === undefined) {
    return spawnedPromise;
  }
  let timeoutId;
  const timeoutPromise = new Promise((resolve, reject) => {
    timeoutId = setTimeout(() => {
      timeoutKill(spawned, killSignal, reject);
    }, timeout);
  });
  const safeSpawnedPromise = spawnedPromise.finally(() => {
    clearTimeout(timeoutId);
  });
  return Promise.race([timeoutPromise, safeSpawnedPromise]);
};
exports.setupTimeout = setupTimeout;
const validateTimeout = _ref4 => {
  let {
    timeout
  } = _ref4;
  if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {
    throw new TypeError("Expected the `timeout` option to be a non-negative integer, got `".concat(timeout, "` (").concat(typeof timeout, ")"));
  }
};

// `cleanup` option handling
exports.validateTimeout = validateTimeout;
const setExitHandler = async (spawned, _ref5, timedPromise) => {
  let {
    cleanup,
    detached
  } = _ref5;
  if (!cleanup || detached) {
    return timedPromise;
  }
  const removeExitHandler = (0, _signalExit.onExit)(() => {
    spawned.kill();
  });
  return timedPromise.finally(() => {
    removeExitHandler();
  });
};
exports.setExitHandler = setExitHandler;