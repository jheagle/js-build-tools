"use strict";

require("core-js/modules/esnext.weak-map.delete-all.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chalk = void 0;
Object.defineProperty(exports, "backgroundColorNames", {
  enumerable: true,
  get: function () {
    return _index.backgroundColorNames;
  }
});
Object.defineProperty(exports, "backgroundColors", {
  enumerable: true,
  get: function () {
    return _index.backgroundColorNames;
  }
});
exports.chalkStderr = void 0;
Object.defineProperty(exports, "colorNames", {
  enumerable: true,
  get: function () {
    return _index.colorNames;
  }
});
Object.defineProperty(exports, "colors", {
  enumerable: true,
  get: function () {
    return _index.colorNames;
  }
});
exports.default = void 0;
Object.defineProperty(exports, "foregroundColorNames", {
  enumerable: true,
  get: function () {
    return _index.foregroundColorNames;
  }
});
Object.defineProperty(exports, "foregroundColors", {
  enumerable: true,
  get: function () {
    return _index.foregroundColorNames;
  }
});
Object.defineProperty(exports, "modifierNames", {
  enumerable: true,
  get: function () {
    return _index.modifierNames;
  }
});
Object.defineProperty(exports, "modifiers", {
  enumerable: true,
  get: function () {
    return _index.modifierNames;
  }
});
exports.supportsColorStderr = exports.supportsColor = void 0;
require("core-js/modules/web.dom-collections.iterator.js");
var _index = _interopRequireWildcard(require("./vendor/ansi-styles/index.js"));
var _index2 = _interopRequireDefault(require("./vendor/supports-color/index.js"));
var _utilities = require("./utilities.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const {
  stdout: stdoutColor,
  stderr: stderrColor
} = _index2.default;
exports.supportsColorStderr = stderrColor;
exports.supportsColor = stdoutColor;
const GENERATOR = Symbol('GENERATOR');
const STYLER = Symbol('STYLER');
const IS_EMPTY = Symbol('IS_EMPTY');

// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping
const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
const styles = Object.create(null);
const applyOptions = function (object) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error('The `level` option should be an integer from 0 to 3');
  }

  // Detect level if not set manually
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === undefined ? colorLevel : options.level;
};
class Chalk {
  constructor(options) {
    // eslint-disable-next-line no-constructor-return
    return chalkFactory(options);
  }
}
exports.Chalk = Chalk;
const chalkFactory = options => {
  const chalk = function () {
    for (var _len = arguments.length, strings = new Array(_len), _key = 0; _key < _len; _key++) {
      strings[_key] = arguments[_key];
    }
    return strings.join(' ');
  };
  applyOptions(chalk, options);
  Object.setPrototypeOf(chalk, createChalk.prototype);
  return chalk;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(_index.default)) {
  styles[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, {
        value: builder
      });
      return builder;
    }
  };
}
styles.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, 'visible', {
      value: builder
    });
    return builder;
  }
};
const getModelAnsi = function (model, level, type) {
  for (var _len2 = arguments.length, arguments_ = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
    arguments_[_key2 - 3] = arguments[_key2];
  }
  if (model === 'rgb') {
    if (level === 'ansi16m') {
      return _index.default[type].ansi16m(...arguments_);
    }
    if (level === 'ansi256') {
      return _index.default[type].ansi256(_index.default.rgbToAnsi256(...arguments_));
    }
    return _index.default[type].ansi(_index.default.rgbToAnsi(...arguments_));
  }
  if (model === 'hex') {
    return getModelAnsi('rgb', level, type, ..._index.default.hexToRgb(...arguments_));
  }
  return _index.default[type][model](...arguments_);
};
const usedModels = ['rgb', 'hex', 'ansi256'];
for (const model of usedModels) {
  styles[model] = {
    get() {
      const {
        level
      } = this;
      return function () {
        for (var _len3 = arguments.length, arguments_ = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          arguments_[_key3] = arguments[_key3];
        }
        const styler = createStyler(getModelAnsi(model, levelMapping[level], 'color', ...arguments_), _index.default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
  styles[bgModel] = {
    get() {
      const {
        level
      } = this;
      return function () {
        for (var _len4 = arguments.length, arguments_ = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          arguments_[_key4] = arguments[_key4];
        }
        const styler = createStyler(getModelAnsi(model, levelMapping[level], 'bgColor', ...arguments_), _index.default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
const proto = Object.defineProperties(() => {}, {
  ...styles,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
const createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === undefined) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
const createBuilder = (self, _styler, _isEmpty) => {
  // Single argument is hot path, implicit coercion is faster than anything
  // eslint-disable-next-line no-implicit-coercion
  const builder = function () {
    for (var _len5 = arguments.length, arguments_ = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      arguments_[_key5] = arguments[_key5];
    }
    return applyStyle(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));
  };

  // We alter the prototype because we must return a function, but there is
  // no way to create a function with a different prototype
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
const applyStyle = (self, string) => {
  if (self.level <= 0 || !string) {
    return self[IS_EMPTY] ? '' : string;
  }
  let styler = self[STYLER];
  if (styler === undefined) {
    return string;
  }
  const {
    openAll,
    closeAll
  } = styler;
  if (string.includes('\u001B')) {
    while (styler !== undefined) {
      // Replace any instances already present with a re-opening code
      // otherwise only the part of the string until said closing code
      // will be colored, and the rest will simply be 'plain'.
      string = (0, _utilities.stringReplaceAll)(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }

  // We can move both next actions out of loop, because remaining actions in loop won't have
  // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
  // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
  const lfIndex = string.indexOf('\n');
  if (lfIndex !== -1) {
    string = (0, _utilities.stringEncaseCRLFWithFirstIndex)(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles);
const chalk = createChalk();
const chalkStderr = exports.chalkStderr = createChalk({
  level: stderrColor ? stderrColor.level : 0
});
var _default = exports.default = chalk;